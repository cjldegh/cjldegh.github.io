<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git提交报错</title>
    <link href="/2022/12/04/git%E6%8A%A5%E9%94%99/"/>
    <url>/2022/12/04/git%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<h3 id="git提交报错"><a href="#git提交报错" class="headerlink" title="git提交报错"></a>git提交报错</h3><ul><li>提交错了分支，是在<code>git commit</code>提交的时候选择了master分支，但是应该提交到其他分支</li><li>解决方法：</li><li>在<code>git push</code>的时候<code>local</code>选择<code>master</code>而<code>Remote</code>则选择需要正确提交的远端分支，这样就可以了解决问题</li><li><img src="/2022/12/04/git%E6%8A%A5%E9%94%99/1.png" class title="错误"></li><li>学习：</li><li>git的commit和push的区别</li><li><ol><li><code>git commit</code>命令是将本地修改过的文件提交到本地库中，而<code>git push</code>命令是将本地库中的最新信息发送给远程库；</li></ol></li><li><ol start="2"><li><code>git commit</code>命令操作的是本地库，而<code>git push</code>命令操作的是远程库。</li></ol></li><li>所以说在<code>commit</code>出错后只是将错误的提交到了本地库，而<code>git push</code>的时候可以修改过来</li><li>其他方法：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>、git reset HEAD^    <span class="hljs-regexp">//</span> 把上次提交恢复为未提交状态<br><span class="hljs-number">2</span>、git status    <span class="hljs-regexp">//</span> 查看当前状态<br><span class="hljs-number">3</span>、git stash    <span class="hljs-regexp">//</span> 将修改add到暂存区，暂存代码<br><span class="hljs-number">4</span>、git checkout 分支    <span class="hljs-regexp">//</span> 切换到需要提交的分支<br><span class="hljs-number">5</span>、git stash pop    <span class="hljs-regexp">//</span> 恢复成功，可提交<br>（然后就可以按照提交步骤提交代码了）<br><span class="hljs-number">6</span>、git pull    <span class="hljs-regexp">//</span> 先更新再提交<br><span class="hljs-number">7</span>、git status    <span class="hljs-regexp">//</span> 查看当前状态<br><span class="hljs-number">8</span>、git add .    <span class="hljs-regexp">//</span> 添加到暂存区<br><span class="hljs-number">9</span>、git commit -m <span class="hljs-string">&#x27;提交注释&#x27;</span><br><span class="hljs-number">10</span>、git push    <span class="hljs-regexp">//</span> 提交到远程<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>返回的数据状态不符合规范</title>
    <link href="/2022/11/27/%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E4%B8%8D%E7%AC%A6%E5%90%88%E8%A7%84%E8%8C%83/"/>
    <url>/2022/11/27/%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E4%B8%8D%E7%AC%A6%E5%90%88%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<ul><li><h3 id="返回的数据状态不符合规范"><a href="#返回的数据状态不符合规范" class="headerlink" title="返回的数据状态不符合规范"></a>返回的数据状态不符合规范</h3></li><li><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4></li><li>在工作事项反馈界面添加新的预算金额的表格来显示该事项所需的预算金额并反馈，但是在保证后台查找出数据的情况下，前端界面不能显示</li><li><img src="/2022/11/27/%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E4%B8%8D%E7%AC%A6%E5%90%88%E8%A7%84%E8%8C%83/2.png" class title="问题1"></li><li>之后检查发现从后端返回的数据<code>code=200</code>,所以不符合规范</li><li><img src="/2022/11/27/%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E4%B8%8D%E7%AC%A6%E5%90%88%E8%A7%84%E8%8C%83/1.png" class title="问题1"></li><li>layui的table组件默认的规定的数据格式为<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  &quot;<span class="hljs-selector-tag">code</span>&quot;: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;count&quot;</span>: <span class="hljs-number">1000</span>,<br>  <span class="hljs-string">&quot;data&quot;</span>: [&#123;&#125;, &#123;&#125;]<br>&#125; <br></code></pre></td></tr></table></figure></li><li><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4></li><li><ol><li>可以使用layui文档中提出的方法借助<code>parseData</code>回调函数将其解析成table组件所规定的数据格式<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">table.render(&#123;<br>  elem: <span class="hljs-string">&#x27;#demp&#x27;</span><br>  ,url: <span class="hljs-string">&#x27;&#x27;</span><br>  ,parseData: <span class="hljs-keyword">function</span>(res)&#123; <span class="hljs-regexp">//</span>res 即为原始返回的数据<br>    return &#123;<br>      <span class="hljs-string">&quot;code&quot;</span>: res.status, <span class="hljs-regexp">//</span>解析接口状态<br>      <span class="hljs-string">&quot;msg&quot;</span>: res.message, <span class="hljs-regexp">//</span>解析提示文本<br>      <span class="hljs-string">&quot;count&quot;</span>: res.total, <span class="hljs-regexp">//</span>解析数据长度<br>      <span class="hljs-string">&quot;data&quot;</span>: res.data.item <span class="hljs-regexp">//</span>解析数据列表<br>    &#125;;<br>  &#125;<br>  <span class="hljs-regexp">//</span>,…… <span class="hljs-regexp">//</span>其他参数<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li>修改后台传递的数据<code>code</code>值</li></ol></li><li><img src="/2022/11/27/%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E4%B8%8D%E7%AC%A6%E5%90%88%E8%A7%84%E8%8C%83/3.png" class title="问题1"></li><li><ol start="3"><li>新创建<code>LayuiPageInfo</code>用于layui的table返回数据</li></ol></li><li><img src="/2022/11/27/%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E4%B8%8D%E7%AC%A6%E5%90%88%E8%A7%84%E8%8C%83/4.png" class title="问题1"></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>导出jar包报错,不是自动配置类</title>
    <link href="/2022/11/26/%E5%AF%BC%E5%87%BAjar%E5%8C%85%E6%8A%A5%E9%94%99-%E4%B8%8D%E6%98%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB/"/>
    <url>/2022/11/26/%E5%AF%BC%E5%87%BAjar%E5%8C%85%E6%8A%A5%E9%94%99-%E4%B8%8D%E6%98%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h4 id="导出jar包报错-不是自动配置类"><a href="#导出jar包报错-不是自动配置类" class="headerlink" title="导出jar包报错,不是自动配置类"></a>导出jar包报错,不是自动配置类</h4><ul><li>问题:在导出jar包的时候出现下面的错误</li><li><ul><li><img src="/2022/11/26/%E5%AF%BC%E5%87%BAjar%E5%8C%85%E6%8A%A5%E9%94%99-%E4%B8%8D%E6%98%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB/1.png" class title="问题1"></li></ul></li><li>原因:</li><li><ol><li>这句话的意思是”不能排序以下类，因为他不是自动配置类”</li></ol></li><li><ol start="2"><li>之后就修改成了<code>@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</code></li></ol></li><li>而这个注释是会自动根据jar包的依赖来自动配置项目。例如就是用了Mybatis，它的配置文件中会指定数据库的相关参数，这个时候<code>exclude=&#123;DataSourceAutoConfiguration.class&#125;</code>，让spring-boot不用根据Maven中依赖自动配置了</li><li>修改之后又出现问题<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-type">Description</span>:<br><br><span class="hljs-type">The</span> bean &#x27;druidProperties&#x27;, defined in <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">path</span> <span class="hljs-title">resource</span> [cn/stylefeng/roses/core/config/<span class="hljs-type">MybatisDataSourceAutoConfiguration</span>.class], <span class="hljs-title">could</span> <span class="hljs-title">not</span> <span class="hljs-title">be</span> <span class="hljs-title">registered</span>. <span class="hljs-title">A</span> <span class="hljs-title">bean</span> <span class="hljs-keyword">with</span> <span class="hljs-title">that</span> <span class="hljs-title">name</span> <span class="hljs-title">has</span> <span class="hljs-title">already</span> <span class="hljs-title">been</span> <span class="hljs-title">defined</span> <span class="hljs-title">in</span> <span class="hljs-title">class</span> <span class="hljs-title">path</span> <span class="hljs-title">resource</span> [cn/stylefeng/guns/config/datasource/<span class="hljs-type">DataSourceConfig</span>.class] <span class="hljs-title">and</span> <span class="hljs-title">overriding</span> <span class="hljs-title">is</span> <span class="hljs-title">disabled</span>.</span><br><br><span class="hljs-type">Action</span>:<br><br><span class="hljs-type">Consider</span> renaming one of the beans or enabling overriding by setting spring.main.allow-bean-definition-overriding=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li>解决办法：在<code>application.yml</code>文件中添加</li><li><img src="/2022/11/26/%E5%AF%BC%E5%87%BAjar%E5%8C%85%E6%8A%A5%E9%94%99-%E4%B8%8D%E6%98%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB/3.png" class title="问题2"></li><li>一般这个配置 会写在springboot的application.properties下面，这个配置主要是声明spring框架是否允许定义重名的bean对象覆盖原有的bean (spring boot默认是false)，spring.main.allow-bean-definition-overriding &#x3D; true就是允许定义相同的bean对象去覆盖原有的</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工作事项失效功能失效</title>
    <link href="/2022/11/25/%E5%B7%A5%E4%BD%9C%E4%BA%8B%E9%A1%B9%E5%A4%B1%E6%95%88%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88/"/>
    <url>/2022/11/25/%E5%B7%A5%E4%BD%9C%E4%BA%8B%E9%A1%B9%E5%A4%B1%E6%95%88%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h4 id="工作事项失效功能失效"><a href="#工作事项失效功能失效" class="headerlink" title="工作事项失效功能失效"></a>工作事项失效功能失效</h4><ul><li><h5 id="需求"><a href="#需求" class="headerlink" title="需求:"></a>需求:</h5></li><li>在工作事项修改时增加工作事项事项的功能，并且如果三层事项失效那么相关对应的三层明细、四层事项、以及四层明细都需要变更失效，对于三层明细、四层事项变更失效时同样如此;但是现在这个功能会出现变更失效流程走完之后事项依然有效的问题</li><li><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1:"></a>问题1:</h5></li><li>在完成修改后保存变更时会通过<code>updateThree()</code>方法(以三层为例)在数据库中缓存一条变更的数据并且利用<code>attribute5</code>属性来保存变更之前的数据id,而在保存的时候会首先查询是否之前就存在未审核的变更，如果保存过就进行修改，如果没有保存过就新建一条数据；</li><li><ul><li><img src="/2022/11/25/%E5%B7%A5%E4%BD%9C%E4%BA%8B%E9%A1%B9%E5%A4%B1%E6%95%88%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88/4.png" class title="图片1"></li></ul></li><li><ul><li><img src="/2022/11/25/%E5%B7%A5%E4%BD%9C%E4%BA%8B%E9%A1%B9%E5%A4%B1%E6%95%88%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88/5.png" class title="图片2"></li></ul></li><li><ul><li>但是经过两次变更但是没有提交审核，BusinessStatus就会是ING</li></ul></li><li><ul><li><img src="/2022/11/25/%E5%B7%A5%E4%BD%9C%E4%BA%8B%E9%A1%B9%E5%A4%B1%E6%95%88%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88/6.JPG" class title="图片3"></li></ul></li><li><h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2:"></a>问题2:</h5></li><li>经过两次变更并且状态是ING的数据进行审核时，会因为系统中默认对新数据的处理而修改<code>status=1</code>;这样就使得失效变更失效（本来失效变更就是将状态修改为<code>status=-1</code>）</li><li><ul><li><img src="/2022/11/25/%E5%B7%A5%E4%BD%9C%E4%BA%8B%E9%A1%B9%E5%A4%B1%E6%95%88%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88/1.png" class title="图片4"></li></ul></li><li><h5 id="问题3"><a href="#问题3" class="headerlink" title="问题3:"></a>问题3:</h5></li><li>变更之后的数据数据库中不删除，知识把状态修改成了0,<code>status=0</code>,但是在进行状态修改时，将全部的与该三层对应的三层明细全部查找出来并进行状态的修改，这样会造成数据出错</li><li><ul><li><img src="/2022/11/25/%E5%B7%A5%E4%BD%9C%E4%BA%8B%E9%A1%B9%E5%A4%B1%E6%95%88%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88/7.png" class title="图片5"></li></ul></li><li><h5 id="问题1-amp-amp-问题2解决办法"><a href="#问题1-amp-amp-问题2解决办法" class="headerlink" title="问题1&amp;&amp;问题2解决办法"></a>问题1&amp;&amp;问题2解决办法</h5></li><li><ol><li>在变更的数据保存时，把<code>BusinessStatus</code>取得数据由之前的如果数据从未变更过就取原数据的值，而若数据变更过则取变更但是未提交的数据的值，修改为一直都取原理啊数据的值，这样就不会出现经过两次变更<code>BusinessStatus=&quot;ING&quot;</code>的情况。在数据审核过程中就不会将失效的status修改为1.</li></ol></li><li><h5 id="问题3解决办法"><a href="#问题3解决办法" class="headerlink" title="问题3解决办法"></a>问题3解决办法</h5></li><li><ol><li>增加查询条件，只修改状态<code>status=1</code>的数据</li></ol></li><li><ol start="2"><li>并且原来数据<code>BusinessStatus=&#39;INVALID&#39;</code>修改为失效</li></ol></li><li><ol start="3"><li><img src="/2022/11/25/%E5%B7%A5%E4%BD%9C%E4%BA%8B%E9%A1%B9%E5%A4%B1%E6%95%88%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88/2.png" class title="图片6"></li></ol></li><li><ol start="4"><li><img src="/2022/11/25/%E5%B7%A5%E4%BD%9C%E4%BA%8B%E9%A1%B9%E5%A4%B1%E6%95%88%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88/3.png" class title="图片7"></li></ol></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DATE_FORMAT</title>
    <link href="/2022/11/19/DATE-FORMAT/"/>
    <url>/2022/11/19/DATE-FORMAT/</url>
    
    <content type="html"><![CDATA[<h3 id="Java时间格式转换"><a href="#Java时间格式转换" class="headerlink" title="Java时间格式转换"></a>Java时间格式转换</h3><ul><li>遇到的问题:在一个实现Excel导入中需要将Excel中的获取的数据转换成Date类型的存入，由于也包括从页面添加的数据，所以要实现两个数据的格式统一。</li><li><img src="/2022/11/19/DATE-FORMAT/1.png" class></li><li>使用这个方法将数据类型进行转换</li></ul><h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><ul><li>日期和时间格式由 日期和时间模式字符串 指定。在 日期和时间模式字符串 中，未加引号的字母 ‘A’ 到 ‘Z’ 和 ‘a’ 到 ‘z’ 被解释为模式字母，用来表示日期或时间字符串元素。</li><li>例如：</li><li><img src="/2022/11/19/DATE-FORMAT/3.png" class></li><li><ol><li>SimpleDateFormat中parse方法，就是上面使用到的方法，主要作用是 将字符串转换成时间，parse()方法返回的是一个Date类型的数据</li></ol></li><li><ol start="2"><li>format方法：将时间转化为字符串，返回的是一个StringBuffer类型的数据</li></ol></li></ul><h4 id="在数据库中的使用"><a href="#在数据库中的使用" class="headerlink" title="在数据库中的使用"></a>在数据库中的使用</h4><ul><li><ol><li>DATE_FORMAT()方法:主要作用是用于以不同的格式显示日期&#x2F;时间数据，下图中的<code>%Y-%m-%d</code>是使用的特定格式</li></ol></li><li><img src="/2022/11/19/DATE-FORMAT/2.png" class></li><li>可用的格式</li><li><img src="/2022/11/19/DATE-FORMAT/4.png" class></li><li><ol start="2"><li>计算日期</li></ol></li><li><img src="/2022/11/19/DATE-FORMAT/5.png" class></li><li>其他计算的方法<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DateUtils</span>.</span></span>set<span class="hljs-constructor">Years(<span class="hljs-params">new</span> Date()</span>, <span class="hljs-number">2019</span>); <span class="hljs-comment">// 根据参数设置日期年份.输出:2019-05-16 19:30:20</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DateUtils</span>.</span></span>add<span class="hljs-constructor">Months(<span class="hljs-params">new</span> Date()</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// 根据参数增加日期月份.输出:2019-04-16 19:30:20</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DateUtils</span>.</span></span>truncate(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>, Calendar.DATE); <span class="hljs-comment">// 根据参数截取日期.输出:2019-04-16 00:00:00</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DateUtils</span>.</span></span>ceiling(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>, Calendar.DATE);  <span class="hljs-comment">// 根据参数向上进位日期.输出:2018-05-17 00:00:00</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DateUtils</span>.</span></span>get<span class="hljs-constructor">FragmentInDays(<span class="hljs-params">new</span> Date()</span>, Calendar.MONTH); <span class="hljs-comment">// 根据参数截取范围内日期后返回天数.输出:16</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DateUtils</span>.</span></span>truncated<span class="hljs-constructor">Equals(<span class="hljs-params">new</span> Date()</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>, Calendar.DATE); <span class="hljs-comment">//根据参数范围比较日期是否相同,该例子只比较年月日.输出:true</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DateUtils</span>.</span></span>truncated<span class="hljs-constructor">CompareTo(<span class="hljs-params">new</span> Date()</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>, Calendar.MONTH); <span class="hljs-comment">//根据参数范围比较日期大小,该例子只比较年月.输出:0</span><br><br>        <span class="hljs-comment">// 举例</span><br>        get<span class="hljs-constructor">FirstSecondOfMonth()</span>; <span class="hljs-comment">// 获取当月第一秒</span><br>        get<span class="hljs-constructor">LastSecondOfMonth()</span>; <span class="hljs-comment">// 获取当月最后一秒</span><br>        get<span class="hljs-constructor">DayOfYear()</span>; <span class="hljs-comment">// 获取日期是该年的第几天</span><br>        get<span class="hljs-constructor">FirstSundayOfMonth()</span>; <span class="hljs-comment">// 获取当月的第一个周日</span><br>    &#125;<br><br>    public static void get<span class="hljs-constructor">FirstSecondOfMonth()</span> &#123;<br>        Date date = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>;<br>        date = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DateUtils</span>.</span></span>truncate(date, Calendar.MONTH); <span class="hljs-comment">// 截取日期到月份</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(date); <span class="hljs-comment">// 输出:2018-05-01 00:00:00</span><br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>获取当前时间<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Date</span> <span class="hljs-built_in">date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <br></code></pre></td></tr></table></figure></li><li>获取当前时间戳<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">long timestamp <span class="hljs-operator">=</span> System.currentTimeMillis()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>日期转时间戳<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">Date</span> <span class="hljs-type">date</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>();<br>String <span class="hljs-type">timestamp</span> = String.valueOf(<span class="hljs-type">date</span>.getTime());<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">timestamp</span>); <br></code></pre></td></tr></table></figure></li><li>时间戳转日期<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">String <span class="hljs-type">timestamp</span> = &quot;1521480110000&quot;;<br><span class="hljs-type">Date</span> <span class="hljs-type">date</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>(<span class="hljs-built_in">new</span> Long(<span class="hljs-type">timestamp</span>));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">date</span>); <br></code></pre></td></tr></table></figure></li><li>日期转字符串<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">SimpleDateFormat sdf = <span class="hljs-built_in">new</span> SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);<br><span class="hljs-type">Date</span> <span class="hljs-type">date</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>();<br>String dateStr = sdf.format(<span class="hljs-type">date</span>);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(dateStr);<br></code></pre></td></tr></table></figure></li><li>字符串转日期<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">SimpleDateFormat sdf <span class="hljs-operator">=</span> new SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)<span class="hljs-comment">;</span><br>String dateStr <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2018-05-16 19:30:20&quot;</span><span class="hljs-comment">;</span><br>Date date <span class="hljs-operator">=</span> sdf.parse(dateStr)<span class="hljs-comment">;</span><br>System.out.println(date)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>日期转日历<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">Date</span> <span class="hljs-type">date</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>();<br>Calendar c = Calendar.getInstance();<br>c.setTime(<span class="hljs-type">date</span>);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(c);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java正则表达式Pattern和Matcher类</title>
    <link href="/2022/11/15/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FPattern%E5%92%8CMatcher%E7%B1%BB/"/>
    <url>/2022/11/15/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FPattern%E5%92%8CMatcher%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h4 id="Java正则表达式Pattern和Matcher类"><a href="#Java正则表达式Pattern和Matcher类" class="headerlink" title="Java正则表达式Pattern和Matcher类"></a>Java正则表达式Pattern和Matcher类</h4><ul><li><strong>遇到的问题</strong>在通过excel导入数据时，需要导入的数据符合区间类型int,int类型的数据，为了避免用户在Excel中使用错误的符号，导致后面的数据判断出错，所以就在后台进行统一判断。</li><li><strong>解决方案</strong></li><li><ol><li>拿到Excel中的数据之后进行是否存在特殊字符串的判断</li></ol></li><li><ol start="2"><li><img src="/2022/11/15/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FPattern%E5%92%8CMatcher%E7%B1%BB/1.png" class title="错误"></li></ol></li><li><ol start="3"><li><code>sign</code>就是字符串中存在的特殊字符</li></ol></li><li><ol start="4"><li>之后将特殊字符之前之后的数据取出，重新字符串组合</li></ol></li><li><ol start="5"><li><img src="/2022/11/15/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FPattern%E5%92%8CMatcher%E7%B1%BB/2.png" class title="错误"></li></ol></li><li><strong>学习</strong></li></ul><ul><li>Pattern类的作用在于编译正则表达式后创建一个匹配模式，把规则编译成模式对象</li><li>Matcher类使用Pattern实例提供的模式信息对正则表达式进行匹配，通过模式对象得到匹配器对象 </li><li>Pattern常用方法的介绍</li><li><ol><li><code>Pattern.pattren()</code>返回正则表达式的字符串形式<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Pattern p<span class="hljs-operator">=</span>Pattern.compile(<span class="hljs-string">&quot;\\w+&quot;</span>)<span class="hljs-comment">; </span><br>p.pattern()<span class="hljs-comment">; //返回 \w+ </span><br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li><code>Pattern.split(CharSequence input)</code>该方法用于分割字符串，并返回一个String[]<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Pattern p<span class="hljs-operator">=</span>Pattern.compile(<span class="hljs-string">&quot;\\d+&quot;</span>)<span class="hljs-comment">; </span><br>String[] str<span class="hljs-operator">=</span>p.split(<span class="hljs-string">&quot;电话是:1234:邮箱是:aaa@aaa.com&quot;</span>)<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="3"><li><code>Pattern.matchers(String regex,CharSequence input)</code>该方法是一个静态方法,用于快速匹配字符串,该方法将会匹配全部字符串<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">Pattern.<span class="hljs-keyword">matches</span>(<span class="hljs-string">&quot;\\d+&quot;</span>,<span class="hljs-string">&quot;2223&quot;</span>);//返回<span class="hljs-keyword">true</span> <br>Pattern.<span class="hljs-keyword">matches</span>(<span class="hljs-string">&quot;\\d+&quot;</span>,<span class="hljs-string">&quot;2223aa&quot;</span>);//返回<span class="hljs-keyword">false</span>,需要匹配到所有字符串才能返回<span class="hljs-keyword">true</span>,这里aa不能匹配到 <br>Pattern.<span class="hljs-keyword">matches</span>(<span class="hljs-string">&quot;\\d+&quot;</span>,<span class="hljs-string">&quot;22bb23&quot;</span>);//返回<span class="hljs-keyword">false</span>,需要匹配到所有字符串才能返回<span class="hljs-keyword">true</span>,这里bb不能匹配到<br></code></pre></td></tr></table></figure></li></ol></li><li><blockquote><p>这里的匹配涉及到正则表达式 \d匹配一个数字后面的加号意思是说明前面这个\d的数字为1到多个</p></blockquote></li><li>上述方法等同于<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Pattern p <span class="hljs-operator">=</span>Pattern.compile(<span class="hljs-string">&quot;a*b&quot;</span>)<span class="hljs-comment">;</span><br>Matcher m <span class="hljs-operator">=</span>p.matcher(<span class="hljs-string">&quot;aaaaab&quot;</span>)<span class="hljs-comment">;</span><br>m.matches()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>Matcher的常用方法介绍</li><li>1.<code> Matcher.matches()</code>matches()方法匹配的是整个字符串<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Pattern p<span class="hljs-operator">=</span>Pattern.compile(<span class="hljs-string">&quot;\\d+&quot;</span>)<span class="hljs-comment">; </span><br>Matcher m<span class="hljs-operator">=</span>p.matcher(<span class="hljs-string">&quot;22bb23&quot;</span>)<span class="hljs-comment">; </span><br>m.matches()<span class="hljs-comment">;//返回false,因为bb不能被\d+匹配,导致整个字符串匹配未成功. </span><br>Matcher m2<span class="hljs-operator">=</span>p.matcher(<span class="hljs-string">&quot;2223&quot;</span>)<span class="hljs-comment">; </span><br>m2.matches()<span class="hljs-comment">;//返回true,因为\d+匹配到了整个字符串 </span><br><br></code></pre></td></tr></table></figure></li><li><ol start="2"><li><code>Matcher.lookingAt()</code>lookingAt()对最前面的字符串进行匹配，只有匹配到的字符串在最前面才返回true.<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Pattern p<span class="hljs-operator">=</span>Pattern.compile(<span class="hljs-string">&quot;\\d+&quot;</span>)<span class="hljs-comment">; </span><br>Matcher m<span class="hljs-operator">=</span>p.matcher(<span class="hljs-string">&quot;22bb23&quot;</span>)<span class="hljs-comment">; </span><br>m.lookingAt()<span class="hljs-comment">;//返回true,因为\d+匹配到了前面的22 </span><br>Matcher m2<span class="hljs-operator">=</span>p.matcher(<span class="hljs-string">&quot;aa2223&quot;</span>)<span class="hljs-comment">; </span><br>m2.lookingAt()<span class="hljs-comment">;//返回false,因为\d+不能匹配前面的aa</span><br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="3"><li><code>Matcher.find()</code>对指定的字符串进行匹配，匹配到的字符串可以在任意位置。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Pattern p<span class="hljs-operator">=</span>Pattern.compile(<span class="hljs-string">&quot;\\d+&quot;</span>)<span class="hljs-comment">; </span><br>Matcher m<span class="hljs-operator">=</span>p.matcher(<span class="hljs-string">&quot;22bb23&quot;</span>)<span class="hljs-comment">; </span><br>m.find()<span class="hljs-comment">;//返回true </span><br>Matcher m2<span class="hljs-operator">=</span>p.matcher(<span class="hljs-string">&quot;aa2223&quot;</span>)<span class="hljs-comment">; </span><br>m2.find()<span class="hljs-comment">;//返回true </span><br>Matcher m3<span class="hljs-operator">=</span>p.matcher(<span class="hljs-string">&quot;aa2223bb&quot;</span>)<span class="hljs-comment">; </span><br>m3.find()<span class="hljs-comment">;//返回true </span><br>Matcher m4<span class="hljs-operator">=</span>p.matcher(<span class="hljs-string">&quot;aabb&quot;</span>)<span class="hljs-comment">; </span><br>m4.find()<span class="hljs-comment">;//返回false</span><br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="4"><li><code>Matcher.start()</code>返回匹配到的子字符串在字符串中的起始位置。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Pattern p<span class="hljs-operator">=</span>Pattern.compile(<span class="hljs-string">&quot;\\d+&quot;</span>)<span class="hljs-comment">; </span><br>Matcher m<span class="hljs-operator">=</span>p.matcher(<span class="hljs-string">&quot;aaa2223bb&quot;</span>)<span class="hljs-comment">; </span><br>m.find()<span class="hljs-comment">;//匹配2223 </span><br>m.start()<span class="hljs-comment">;//返回3 </span><br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="5"><li><code>Matcher.end()</code>返回匹配到的子字符串的最后一个字符的<strong>下一个</strong>索引值。</li></ol></li><li><ol start="6"><li><code>Matcher.group()</code>返回匹配到地字符串<strong>注意：在使用之前必须使用find()</strong><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Pattern p<span class="hljs-operator">=</span>Pattern.compile(<span class="hljs-string">&quot;\\d+&quot;</span>)<span class="hljs-comment">; </span><br>Matcher m<span class="hljs-operator">=</span>p.matcher(<span class="hljs-string">&quot;aaa2223bb&quot;</span>)<span class="hljs-comment">; </span><br>m.find()<span class="hljs-comment">;//匹配2223</span><br>m.group()<span class="hljs-comment">;//返回2223</span><br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="7"><li><code>Matcher.start(int, i), Matcher.end(int, i), Matcher.group(int, i), Matcher.groupCount()</code>分组操作<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">Pattern p=Pattern.compile(<span class="hljs-string">&quot;([a-z]+)(\\d+)&quot;</span>);  <span class="hljs-regexp">//</span>()表示分组，意义是括号内是一个整体<br>Matcher m=p.matcher(<span class="hljs-string">&quot;aaa2223bb&quot;</span>); <br>m.find();   <span class="hljs-regexp">//</span>匹配aaa2223 <br>m.groupCount();   <span class="hljs-regexp">//</span>返回<span class="hljs-number">2</span>,因为有<span class="hljs-number">2</span>组 <br>m.start(<span class="hljs-number">1</span>);   <span class="hljs-regexp">//</span>返回<span class="hljs-number">0</span> 返回第一组匹配到的子字符串在字符串中的索引号 <br>m.start(<span class="hljs-number">2</span>);   <span class="hljs-regexp">//</span>返回<span class="hljs-number">3</span> 返回第二组匹配到的子字符串在字符串中的索引号 <br>m.end(<span class="hljs-number">1</span>);   <span class="hljs-regexp">//</span>返回<span class="hljs-number">3</span> 返回第一组匹配到的子字符串的最后一个字符在字符串中的索引位置. <br>m.end(<span class="hljs-number">2</span>);   <span class="hljs-regexp">//</span>返回<span class="hljs-number">7</span> 返回第二组匹配到的子字符串的最后一个字符在字符串中的索引位置. <br>m.group(<span class="hljs-number">1</span>);   <span class="hljs-regexp">//</span>返回aaa,返回第一组匹配到的子字符串 <br>m.group(<span class="hljs-number">2</span>);   <span class="hljs-regexp">//</span>返回<span class="hljs-number">2223</span>,返回第二组匹配到的子字符串 <br></code></pre></td></tr></table></figure></li></ol></li><li><blockquote><p>只有当匹配成功后，才可以使用start(), end(), group()方法，否则会抛出java.lang.IllegalStateException</p></blockquote></li><li>正则的表达式用法</li><li><img src="/2022/11/15/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FPattern%E5%92%8CMatcher%E7%B1%BB/3.png" class title="错误"></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>更新table2.0</title>
    <link href="/2022/11/11/%E6%9B%B4%E6%96%B0table2-0/"/>
    <url>/2022/11/11/%E6%9B%B4%E6%96%B0table2-0/</url>
    
    <content type="html"><![CDATA[<h3 id="更新table2-0"><a href="#更新table2-0" class="headerlink" title="更新table2.0"></a>更新table2.0</h3><ul><li>继之前的layui日期的使用以及动态更新table和form,在之后开发的过程中又总结的的方法</li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>layui报错table</title>
    <link href="/2022/11/11/layui%E6%8A%A5%E9%94%99table/"/>
    <url>/2022/11/11/layui%E6%8A%A5%E9%94%99table/</url>
    
    <content type="html"><![CDATA[<h3 id="layui-table报错"><a href="#layui-table报错" class="headerlink" title="layui table报错"></a>layui table报错</h3><p><strong>错误</strong></p><ul><li>定义了一个数组来存放不同条件的table表头，但是一直运行出错，删除添加的数组就正常运行</li><li><img src="/2022/11/11/layui%E6%8A%A5%E9%94%99table/1.png" class></li><li>layui的table中存在这个render方法</li><li><strong>解决思路</strong></li><li><code>table.render()</code>没有被定义，但是检查完成已经被定义了</li><li><strong>解决办法</strong></li><li>是因为数组名称定义为了<code>var table = []</code>,所以在定义之后的，就默认是这个数组，所以就不会有自带的<code>render()</code>方法</li><li>修改数组名就行了</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>List集合的Stream流处理</title>
    <link href="/2022/11/10/List%E9%9B%86%E5%90%88%E7%9A%84Stream%E6%B5%81%E5%A4%84%E7%90%86/"/>
    <url>/2022/11/10/List%E9%9B%86%E5%90%88%E7%9A%84Stream%E6%B5%81%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="List集合的Stream流处理"><a href="#List集合的Stream流处理" class="headerlink" title="List集合的Stream流处理"></a>List集合的Stream流处理</h3><ul><li><strong>问题</strong> 根据每年的数据生成一张包含各种信息的统计表，就是每年可能有不同的大指标而大指标之下又会分成1，2，3等等很多小指标，这些小指标都会分别存入数据库中（无序）</li><li><strong>解决办法</strong>使用下面这种方式来将每个小指标根据大指标来排一下序</li><li><img src="/2022/11/10/List%E9%9B%86%E5%90%88%E7%9A%84Stream%E6%B5%81%E5%A4%84%E7%90%86/1.png" class title="方法"></li><li>一般适用于list集合，主要作用是模拟SQL查询，从集合中查询想要的数据，filter里面的参数是指集合里面的每一项</li><li>之后还需要将大指标相同的数据，把大指标合并成为一个渲染到表格中，就需要去重</li><li><img src="/2022/11/10/List%E9%9B%86%E5%90%88%E7%9A%84Stream%E6%B5%81%E5%A4%84%E7%90%86/2.png" class title="方法"></li><li>而上图中的OneName就相当于是大指标，来按照这个去重保存到<code>same_one_list</code>中</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文件导出@Excel</title>
    <link href="/2022/11/10/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA-Excel/"/>
    <url>/2022/11/10/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA-Excel/</url>
    
    <content type="html"><![CDATA[<h3 id="文件导出的-Excel"><a href="#文件导出的-Excel" class="headerlink" title="文件导出的@Excel"></a>文件导出的@Excel</h3><ul><li>是个小问题</li><li>在导出文件的时候一直会报一个<code>index:0</code>的错误；搜索也找不到解决办法</li><li>之后又搜索了很多文件导出的例子才发现，需要在实体类中加入注解<code>@Excel自定义注解</code></li><li><code>@Excel</code> 作用到filed上面，是对Excel列的一个描述</li><li>这是可能会使用到的</li><li><img src="/2022/11/10/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA-Excel/1.png" class title="方法"></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>layui日期的使用以及动态更新table和form</title>
    <link href="/2022/11/09/layui%E6%97%A5%E6%9C%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0table%E5%92%8Cform/"/>
    <url>/2022/11/09/layui%E6%97%A5%E6%9C%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0table%E5%92%8Cform/</url>
    
    <content type="html"><![CDATA[<h3 id="layui日期的使用"><a href="#layui日期的使用" class="headerlink" title="layui日期的使用"></a>layui日期的使用</h3><ul><li>在使用日期选择框的时候一直报下面这个错</li><li><img src="/2022/11/09/layui%E6%97%A5%E6%9C%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0table%E5%92%8Cform/1.png" class title="错误"></li><li>原因：没有加载模块，因为<code>layui</code>有很多模块，如果没有使用<code>layui.all.js</code>那么就需要在使用的时候用<code>layui.use</code>加载模块<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php">layui.<span class="hljs-keyword">use</span>([<span class="hljs-string">&#x27;laydate&#x27;</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="动态的更新select下拉框"><a href="#动态的更新select下拉框" class="headerlink" title="动态的更新select下拉框"></a>动态的更新select下拉框</h3><ul><li>在layui中的下拉框需要分开不同两年的数据，举个栗子：也就是选择18年后，相应的班级下拉框显示18级，年份选择19级，班级下拉框显示19级，数据库已经由不同年份分开</li><li><strong>解决办法</strong>：首先使用laydate来选择不同的年份，选择完成后，给year赋值现在选择的年份，之后调用动态配置下拉框的方法</li><li><img src="/2022/11/09/layui%E6%97%A5%E6%9C%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0table%E5%92%8Cform/2.png" class title="解决办法"></li><li>之后还会遇到 option堆叠的问题，也就是先查18年的数据，再查19年的数据，下拉框会同时显示18.19的数据</li><li><strong>解决办法</strong></li><li><img src="/2022/11/09/layui%E6%97%A5%E6%9C%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0table%E5%92%8Cform/3.png" class title="解决办法"></li><li>同样，非动态但是有判断条件的控制，需要在后面加上<code>form.render();</code>才能实现</li></ul><hr><h3 id="动态的更新table"><a href="#动态的更新table" class="headerlink" title="动态的更新table"></a>动态的更新table</h3><ul><li><img src="/2022/11/09/layui%E6%97%A5%E6%9C%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0table%E5%92%8Cform/4.png" class title="问题"></li><li>确实出现这个问题但是对我好像不能直接套用；因为我首先会根据年份·搜索首页面，并且之后还会用年份固定条件搜索，所以说 我在搜索的方法里面加了</li><li><img src="/2022/11/09/layui%E6%97%A5%E6%9C%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0table%E5%92%8Cform/5.png" class title="解决办法"></li><li>这个方法；<br>之后调用渲染表格的方法，就可以实现了</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>需要修改多条明细</title>
    <link href="/2022/11/06/%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9%E5%A4%9A%E6%9D%A1%E6%98%8E%E7%BB%86/"/>
    <url>/2022/11/06/%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9%E5%A4%9A%E6%9D%A1%E6%98%8E%E7%BB%86/</url>
    
    <content type="html"><![CDATA[<h5 id="同时修改多条明细"><a href="#同时修改多条明细" class="headerlink" title="同时修改多条明细"></a>同时修改多条明细</h5><p>HashSet 是一个没有重复元素的集合。<br>它是由HashMap实现的，不保证元素的顺序，而且HashSet允许使用 null 元素。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Set&lt;<span class="hljs-keyword">String</span>&gt;ids=<span class="hljs-keyword">new</span><span class="hljs-type">HashSet</span>&lt;&gt;();<span class="hljs-comment">//</span><br><span class="hljs-keyword">String</span>[]transFactor=&#123;&#125;;<br><br></code></pre></td></tr></table></figure><p>我们经常将数据放到集合中进行操作，因为java集合给我们提供了大量的方法函数使用，大大减少了我们的开发工作量。但是有时候我们需要的却是基础数据类型，比如数组，此时我们将集合类型转成数组。虽然集合类有个toArray()方法，但是返回的是Object[]类型，通常情况下我们可以考虑使用stream流进行转.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">target<span class="hljs-selector-class">.forEach</span>(t-&gt;&#123;<br>    ids<span class="hljs-selector-class">.add</span>(t<span class="hljs-selector-class">.getId</span>())<br>&#125;)<br><br>lineWrapper<span class="hljs-selector-class">.in</span>(<span class="hljs-string">&quot;target_id&quot;</span>,ids<span class="hljs-selector-class">.toArray</span>(transFactor))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>layui</title>
    <link href="/2022/11/05/layui/"/>
    <url>/2022/11/05/layui/</url>
    
    <content type="html"><![CDATA[<h5 id="layui的渲染方式"><a href="#layui的渲染方式" class="headerlink" title="layui的渲染方式"></a>layui的渲染方式</h5><ol><li>用的最多的是访问url,之后会将数据渲染到表格中。。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php">table.<span class="hljs-title function_ invoke__">render</span>(&#123;<br>    <span class="hljs-attr">elem</span>: <span class="hljs-string">&#x27;#demo&#x27;</span><br>    ,<span class="hljs-attr">height</span>: <span class="hljs-number">312</span><br>    ,<span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;../../demo/table/user/-page=1&amp;limit=30.js&#x27;</span> //数据接口<br>    ,<span class="hljs-attr">page</span>: <span class="hljs-literal">true</span> //开启分页<br>    ,<span class="hljs-attr">cols</span>: [[ //表头<br>      &#123;<span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;ID&#x27;</span>, <span class="hljs-attr">width</span>:<span class="hljs-number">80</span>, <span class="hljs-attr">sort</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">fixed</span>: <span class="hljs-string">&#x27;left&#x27;</span>&#125;<br>      ,&#123;<span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;用户名&#x27;</span>, <span class="hljs-attr">width</span>:<span class="hljs-number">80</span>&#125;<br>      ,&#123;<span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;sex&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;性别&#x27;</span>, <span class="hljs-attr">width</span>:<span class="hljs-number">80</span>, <span class="hljs-attr">sort</span>: <span class="hljs-literal">true</span>&#125;<br>      ,&#123;<span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;city&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;城市&#x27;</span>, <span class="hljs-attr">width</span>:<span class="hljs-number">80</span>&#125; <br>    ]]<br>  &#125;);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+Github博客搭建教程</title>
    <link href="/2022/11/03/%E9%99%88%E4%BD%B3%E4%B9%90%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/11/03/%E9%99%88%E4%BD%B3%E4%B9%90%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h5 id="博客基于Hexo。Hexo是高效的静态网站生成框架，它基于Node-js，快速，简单且功能强大，是搭建博客的首选框架。"><a href="#博客基于Hexo。Hexo是高效的静态网站生成框架，它基于Node-js，快速，简单且功能强大，是搭建博客的首选框架。" class="headerlink" title="博客基于Hexo。Hexo是高效的静态网站生成框架，它基于Node.js，快速，简单且功能强大，是搭建博客的首选框架。"></a>博客基于Hexo。Hexo是高效的静态网站生成框架，它基于Node.js，快速，简单且功能强大，是搭建博客的首选框架。</h5><ol><li>搭建Hexo<ol><li>安装git：<ol><li>为了把本地的网页文件上传到github上面去，需要用到工具———Git[下载地址]。Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git教程(学习教程，不是安装教程)</li><li>安装完成后在命令提示符中输入<code>git --version</code>来查看一下版本验证是否安装成功</li></ol></li><li>安装node.js：Hexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。<ol><li>官网下载 <a href="http://nodejs.cn/">node.js官网</a></li><li>这里要特别注意,这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\Users\用户名\AppData\Roaming\npm】路径中，占C盘空间。 安装的文件夹【D:\nodejs】下创建两个文件夹【node_global】及【node_cache】</li><li>安装时有个问题在下面会提到</li><li>打开命令行终端，输入: <code>node-v</code>、<code>npm-v</code> 检查是否安装成功</li></ol></li><li>安装Hexo<ol><li>创建一个文件夹来存放自己的博客文件，然后cd到这个文件夹下面，或者在这个文件夹下面直接右击 git bash打开</li><li>输入 <code>npm install -g hexo-cli</code> 安装hexo</li><li>完成后<code>hexo -v</code> 验证是否成功</li><li><strong>遇到的问题 ：使用npm安装时是全局安装，所以在上面安装node时需要特别注意配置环境变量；我在环境变量配置了使用nvm的node.js的位置，但是却没有将全模块所在路径和缓存路径放在我node.js安装的文件夹中，所以就会报错；‘hexo’ 不是内部或外部命令，也不是可运行的程序</strong></li><li>初始化：接下来初始化一下hexo,即初始化我们的网站，进入我们主题根目录Hexo，输入<code>hexo init</code>初始化文件夹</li><li>输入hexo g生成静态网页，然后输入hexo s打开本地服务器，按ctrl+c关闭本地服务器.</li></ol></li><li>注册github创建个人账号<ol><li>打开<a href="https://github.com/%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93New">https://github.com/，新建一个项目仓库New</a> repository，如下所示；存储库要按照下面这个格式只有这样，将来要部署到GitHub page的时候，才会被识别</li></ol></li><li>生成SSH添加到gitHub上<ol><li>第一次使用git后需要将用户名和邮箱初始化，在之前存放博客创建的文件夹中，右键打开 git bash输入</li><li><code>git config -- global user.name &quot;yourname&quot;  git config -- global user.email &quot;email&quot; </code></li><li>用下面的语句检查一下：</li><li><code> git config user.name  git config user.email</code></li><li>然后创建ssh:ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上</li><li><code>ssh-keygen -t rsa -C &quot;youremail&quot;</code> 自己git的邮箱，一直回车</li><li>这个时候生成了.ssh文件。在电脑中找到，或者git bash中输入<code>cat ~/.ssh/id_rsa.pub</code></li><li>打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。</li><li>在git bash输入 <code>ssh -T git@github.com</code>，出现你的用户名，那就成功了</li></ol></li><li>将hexo部署到github上<ol><li>将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。修改最后一行的配置</li><li>其中 <code>hexo clean</code>清除了之前生成的东西，也可以不加。 <code>hexo generate</code>生成静态文章，可以用 <code>hexo g</code>缩写 ，<code>hexo deploy</code>部署文章，可以用<code>hexo d</code>缩写</li><li>过一会儿就可以在<code>http://yourname.github.io</code> 这个网站看到博客了</li></ol></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
